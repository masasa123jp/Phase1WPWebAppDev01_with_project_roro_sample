// bundle.js - combined modules from src
(function() {
// Auto-generated assets data with hero alias
const assetsData = {
  "tiles": {
    "grass": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALElEQVR4nGOM2uH7/8un9ww8fIIM5NBMlGjm4RNkYKJE86gLRl0w6gIqugAAHDiCYgVLXCsAAAAASUVORK5CYII=",
    "forest": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR4nGPUTTD4z4AEmAS4GPCBfx++ofCZ8KomAowawMDAgi6AHMqylz4wMDAwMDzWE6CdC0YNGDWAgYGBAQBNugrCPe9ywgAAAABJRU5ErkJggg==",
    "mountain": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAlklEQVR4nKWSMRIDIQhFSfAwVlR0VHRUVB7AY3ubTZHZnTFRohtmfoXwHjM+aq0HBJVzhtbatP+MhgEAEDHshwuICBARiGj6Jv1DDw2YGRDxCjPvGaQUysUGItLRz4jImsHK7VMDVR3Sz6hqbLBD/zIwM0gp/YyZjQ126Z2Bu4e3f8bde4M79GtBKeXWcCnlvWD1143qBbYDEaxZO43LAAAAAElFTkSuQmCC",
    "desert": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMElEQVR4nGM81mn4n4ECwESJZgYGBgYWPkUligyg3AWf7t8bYBeMhsFoGDAMhjAAAFqOC/5CBXj+AAAAAElFTkSuQmCC",
    "snow": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR4nGM8fvfPf2UxZgYYuPvqLwMpfMZXn///J1fz3Vd/GZgo0awsxgwxgFzNDAwMDEyUaB4Ng9EwGEZhAAAecM9zh5COjAAAAABJRU5ErkJggg==",
    "swamp": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOElEQVR4nGMMzdb/z0ABYKJE86gBg9aAm3c+EmTjNUBdhR+uARuboAH4NGNzBVYvkOIKxtG8wAAAIWgj7ZVKzIIAAAAASUVORK5CYII=",
    "water": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALUlEQVR4nGO0zF75n4ECwCImpkGJfgYminRTwwCWV69uUGbAaBiMhgHDsAgDAOgcC87f/sEmAAAAAElFTkSuQmCC",
    "road": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAALUlEQVR4nGNcUmT1n4ECwPL8xUdK9DMwUaSbGgawSErwU2bAaBiMhgHDsAgDAFHYDj1d6tjJAAAAAElFTkSuQmCC",
    "castle": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAP0lEQVR4nGNgGPKAEcZY1XHoP7Gawirs4PqYKHUBC4xx4/4Dsgyg2AXDwAAWXBI7T2yCs90t/GjngmFgAMUAAHB4CbO3ZhEZAAAAAElFTkSuQmCC",
    "temple": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR4nGNgGNTg5lr//zfX+v/Hp4aJUksoNoARxiDkVHSgHryRkbouYGBgYLhy4QRRrtAxsIDrG/hAHDWACgZQDAAuuQ2/wbHSRAAAAABJRU5ErkJggg==",
    "town": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR4nGNgGAUUA0YGBgaGsqyo/+Ro7pq2jJGJUhdQbAAjjLE1U4ckb3hPv8JIFRdQbAALLolZx5/B2WmWUrRzwcAbQDEAAO6ACxUMEQ7MAAAAAElFTkSuQmCC",
    "inn": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAc0lEQVR4nGNgGAUUA0YGBgaGm8fz/5OjWd1yIiMTsoCakTlD1+RdDF2TdzGoGZkTZQgLusCc+bUkuYIF5pSti+3+o9t65855nBq9Yw8xYrhg26oZJNnOwMDAwERYCX6AEQYwsG77azg7yFOUdi4YeAMoBgASoxegseRUxgAAAABJRU5ErkJggg==",
    "shop": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAcElEQVR4nGNgGAUUA0YGBgaGrc1R/8nR7F27jJEJWcDLlZWhaeFWBi9XVgYvV1aiDGHCJmgRs4FoVzDCGFF23P+XdoWgSEaXrcGpcdmhr4wMDAwMLMRqwAWweoEUwIJL4u4zhJSy1B/auWDgDaAYAADgzhRsGNLwXgAAAABJRU5ErkJggg==",
    "ship": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOklEQVR4nGNgGAW0BwVOIv9fvXr1H5c8E6UW0M8AXN4YeC8wInO6o7RxhjYyKF12Fa5v4L1AsQEUAwA5Ow1RtNylLgAAAABJRU5ErkJggg==",
    "airship": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASUlEQVR4nGNgGPTgz8us//jkGUnRyCI+DUM9E3nuImAALmdjE8dqADan4hKn2AsEAaFYoBhg9ev34wxYbeW0xFRPm2gcWgZQDACpHBWv2nCQGQAAAABJRU5ErkJggg==",
    "npc": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR4nGNgGAUUA0YGBgaGsqyo/+Ro7pq2jJGJUhdQbAAjjLE1U4ckb3hPv8JIFRdQbAALLolZx5/B2WmWUrRzwcAbQDEAAO6ACxUMEQ7MAAAAAElFTkSuQmCC"
  },
  "characters": {
    // Updated hero_m sprite with shading
    "hero_m": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAVElEQVR4nGNgwAIOFNj9x4axqSVaM1UMYSAFHKBE8/87m/5jw6QZAANIbPoZ8Oyq0X9smCQX2KScQMEkh4HNgBoABf/RMAN9DYgxEvmPjOlvALEAALWl1jVo7Ys9AAAAAElFTkSuQmCC",
    "hero_f": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR4nGNkQAMrUq3+o4shg4jZxxiR+Uz4FBMDKDaAEZvghwsbsHpDwCAAQz3tvCBgEICVTbQBHy5swMpGBxh+0gtZijcaL62Jxh2NhDRjU0PdQER3HjaA1wvkAKw2BhgrYQ2LDWfvUT8hDTwAAAf7HhnwdZ5sAAAAAElFTkSuQmCC",
    "warrior_m": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR4nGNkQAOmCpL/0cWQwekHzxmR+Uz4FBMDKDaAEZvghwsbsHpDwCAAQz3tvCBgEICVTbQBHy5swMpGBxh+KvXTxxuN3Zsu4o5GQpqxqaFuIKI7DxvA6wVyAFYbA4yVsIbFhrP3qJ+QBh4AALBYHhnwtZDfAAAAAElFTkSuQmCC",
    "warrior_f": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR4nGNkQAOFpgr/0cWQQf/pB4zIfCZ8iokBFBvAiE3ww4UNWL0hYBCAoZ52XhAwCMDKJtqADxc2YGWjAww/dcVa4I3GssUncEcjIc3Y1FA3ENGdhw3g9QI5AKuNAcZKWMNiw9l71E9IAw8A7qweGVTOdToAAAAASUVORK5CYII=",
    "mage_m": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAbklEQVR4nGNkQAMJBsX/0cWQwYILvYzIfCZ8iokBFBvAiE3ww4UNWL0hYBCAoZ52XhAwCMDKJtqADxc2YGWjAww/BVhX4I3GDUc7cEcjIc3Y1FA3ENGdhw3g9QI5AKuNAcZKWMNiw9l71E9IAw8A1lweGeG+qa4AAAAASUVORK5CYII=",
    "mage_f": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR4nGNkQAMOlrP+o4shgwPH0xiR+Uz4FBMDKDaAEZvghwsbsHpDwCAAQz3tvCBgEICVTbQBHy5swMpGBxh+8nNbgTcaN+2KwB2NhDRjU0PdQER3HjaA1wvkAKw2BhgrYQ2LDWfvUT8hDTwAABlvHhnYcd1AAAAAAElFTkSuQmCC",
    "priest_m": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR4nGNkQAM7lvT8RxdDBh4xJYzIfCZ8iokBFBvAiE3ww4UNWL0hYBCAoZ52XhAwCMDKJtqADxc2YGWjAww/XblwAm806hhY4I5GQpqxqaFuIKI7DxvA6wVyAFYbA4yVsIbFhrP3qJ+QBh4AAI7eHhlhHOfOAAAAAElFTkSuQmCC",
    "priest_f": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR4nGNkQAM3Nqz4jy6GDDQCIhiR+Uz4FBMDKDaAEZvghwsbsHpDwCAAQz3tvCBgEICVTbQBHy5swMpGBxh+evXgAd5oFFNQwB2NhDRjU0PdQER3HjaA1wvkAKw2BhgrYQ2LDWfvUT8hDTwAAN6WHhkb7UBXAAAAAElFTkSuQmCC",
    "thief_m": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR4nGNkQANeRgr/0cWQwbZzDxiR+Uz4FBMDKDaAEZvghwsbsHpDwCAAQz3tvCBgEICVTbQBHy5swMpGBxh+som0wRuNR5YfwR2NhDRjU0PdQER3HjaA1wvkAKw2BhgrYQ2LDWfvUT8hDTwAAJB0HhlbLpGmAAAAAElFTkSuQmCC",
    "thief_f": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAb0lEQVR4nGNkQANRenr/0cWQwbJLlxiR+Uz4FBMDKDaAEZvghwsbsHpDwCAAQz3tvCBgEICVTbQBHy5swMpGBxh+inTIwhuNyw9Mwx2NhDRjU0PdQER3HjaA1wvkAKw2BhgrYQ2LDWfvUT8hDTwAAMy8HhmwdzrtAAAAAElFTkSuQmCC",
    "npc": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAASElEQVR4nGNgGAUUA0YGBgaGsqyo/+Ro7pq2jJGJUhdQbAAjjLE1U4ckb3hPv8JIFRdQbAALLolZx5/B2WmWUrRzwcAbQDEAAO6ACxUMEQ7MAAAAAElFTkSuQmCC",
    // Hero alias uses the same shaded sprite as hero_m
    "hero": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAVElEQVR4nGNgwAIOFNj9x4axqSVaM1UMYSAFHKBE8/87m/5jw6QZAANIbPoZ8Oyq0X9smCQX2KScQMEkh4HNgBoABf/RMAN9DYgxEvmPjOlvALEAALWl1jVo7Ys9AAAAAElFTkSuQmCC",
    "hero_walk": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAPoAAAD6AG1e1JrAAAAWElEQVR4nGNgwAIOFNj9x4axqSVaM1UMYSAFHKBE8/87m/5jw6QZAANIbPoZ8Oyq0X9smCQX2KScQMEkh4HNgBqABkAa/1Oi8T+5BoBBjJHIfxCmn0ZSAQAeNs2zUHY0cwAAAABJRU5ErkJggg=="
  },
  "monsters": {
    "slime": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR4nGNgGAV0ADP//8cnzUiSxnRGDPVMJNmKRRy7ASQATANgtqQjuTYdt0+xy+ALOLRwoIEXsNhCUHxoAwAb2hIL8vfUcgAAAABJRU5ErkJggg==",
    "bat": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAOUlEQVR4nGNgGAXDADAic1L0Fv8nRtOcS7FwfUyUugCvAXMuxTLMuRRLvukpeov/E/IWxV4YBQwMAMYbDAYd8zvoAAAAAElFTkSuQmCC",
    "skeleton": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQElEQVR4nGNgGPKAEZvghw8f/mMTFxAQwFDPRKkLcBogICCAlU20AR8+fMDKpjrAGohQW1ECElsADhMXjAIGBgDlrRIKIEte+gAAAABJRU5ErkJggg==",
    "orc": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAARUlEQVR4nGNgGJ7gy6Ou/8SIMTAwMDCiC0R1WWFVCAPLyo6h6GEi1XXoAKcBy8qOYWUTbUBUlxVWNtEGEAuGgQGjgIEBACDvEM660duSAAAAAElFTkSuQmCC",
    "dragon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAY0lEQVR4nGNgGF5gg6Xmf1LYVNHMiM0gDUFBBgYGBoYb798zoLM1th1j3GCp+T/g+HVGDAMIaYaxYZqxuuCGlxXcmRrbjsHEGJDEUPSwoBuAZhg+aQYGBgYGJoIqhr8BwwAAAGLoM/Rk76xCAAAAAElFTkSuQmCC",
    "mage_monster": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR4nGNgGGjAiC7gq1v1H5+GzZfbUPQwUeoCig3A8AIDAwNDtHU3Vm8sPVqKoZ62Xlh6tJRh6dFSvAaw4JOMtu6mzAXEgGFgwDAAAMYzDParUqcfAAAAAElFTkSuQmCC",
    "fenrir": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAV0lEQVR4nGNgGPKAEZeEf9vi/9KaBgwMDAwMT69fYNhYFYtTLVaQtf7yfwYGhv8MDAz/oWysgIWAIQQtwnAWPtsYGBgYpgXqouhhImgFATBqABUMGAYAAAyOFNNzt2jqAAAAAElFTkSuQmCC",
    "seacreature": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQUlEQVR4nGNgGAUDDxjRBey2L/+PT8Mhz0gUPUyUugDFAO3+OrjthzwjGbCxkdXgdYHd9uVY2XhdQA4Y+EAcBgAAdagSezM7bMUAAAAASUVORK5CYII=",
    "minotaur": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAATklEQVR4nGNgGGjAiE3wxpH+/1vaFqCI+VQlMGjYFGKoZ8JmADaF2MRwGgADJdsuMpRsu4hPCaYXerz0/xMwFEUPXhcQA0YNGAwGDAMAAMm+ELf6z8BTAAAAAElFTkSuQmCC",
    "ghost": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAQ0lEQVR4nGNgGPKAEZfEhiP3/iPzA2yUsKplwmd6gI0SQ4CNEl4XsOCT3HDkHl7NOF2A7nxcYjgNIAWMGkAFA4YBAAAgAA5mF3pMtwAAAABJRU5ErkJggg=="
  }
};
// assets.js
// assets_data.js に埋め込まれたBase64データから Image オブジェクトを生成します。



// Imageオブジェクトを作成するユーティリティ
function createImageFromDataUri(uri) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.src = uri;
    img.onload = () => resolve(img);
    img.onerror = (err) => reject(err);
  });
}

/**
 * すべてのアセットを読み込み、Imageオブジェクトを返します。
 * データURIから読み込むためファイルI/Oが不要です。
 */
async function loadAssets() {
  const result = { tiles: {}, characters: {}, monsters: {} };
  // tiles
  const tilePromises = Object.entries(assetsData.tiles).map(async ([key, uri]) => {
    result.tiles[key] = await createImageFromDataUri(uri);
  });
  const characterPromises = Object.entries(assetsData.characters).map(async ([key, uri]) => {
    result.characters[key] = await createImageFromDataUri(uri);
  });
  const monsterPromises = Object.entries(assetsData.monsters).map(async ([key, uri]) => {
    result.monsters[key] = await createImageFromDataUri(uri);
  });
  await Promise.all([...tilePromises, ...characterPromises, ...monsterPromises]);
  return result;
}// data.js
// このモジュールでは呪文、アイテム、モンスター、職業、レベルテーブルなどのゲームデータを定義します。

// 呪文の定義
const SPELLS = {
  fire:   { name: 'ファイア',   mp: 2, power: 8, type: 'attack' },
  ice:    { name: 'アイス',    mp: 2, power: 8, type: 'attack' },
  heal:   { name: 'ヒール',    mp: 3, power: 10, type: 'heal' },
  fireball: { name: 'ファイアボール', mp: 4, power: 20, type: 'attack' },
  blizzard: { name: 'ブリザード', mp: 4, power: 20, type: 'attack' },
  thunder:  { name: 'サンダー',  mp: 5, power: 30, type: 'attack' },
  cure:     { name: 'キュア',     mp: 5, power: 25, type: 'heal' },
  healall:  { name: 'ヒールオール', mp: 8, power: 999, type: 'heal' },
  strength: { name: 'ストレングス', mp: 4, power: 0, type: 'buff', stat: 'atk', amount: 5, duration: 99 },
  protect:  { name: 'プロテクト',  mp: 4, power: 0, type: 'buff', stat: 'def', amount: 5, duration: 99 }
};

// アイテムの定義
const ITEMS = {
  potion:   { name: 'ポーション',    heal: 20, cost: 10 },
  ether:    { name: 'エーテル',      mpHeal: 10, cost: 20 },
  antidote: { name: '毒消し草',      curePoison: true, cost: 8 },
  herb:     { name: '薬草',          heal: 50, cost: 30 },
  atkSeed:  { name: '力のタネ',      buff: { stat: 'atk', amount: 3, duration: 99 }, cost: 40 },
  defSeed:  { name: '守りのタネ',    buff: { stat: 'def', amount: 3, duration: 99 }, cost: 40 },
  barrier:  { name: 'バリア巻物',    buff: { stat: 'def', amount: 10, duration: 5 }, cost: 60 }
  ,
  elixir:   { name: 'エリクサー',    heal: 999, mpHeal: 999, cost: 120 },
  magicSeed:{ name: '魔力のタネ',     buff: { stat: 'mp', amount: 5, duration: 99 }, cost: 70 },
  // 武器: type=weapon, atk bonus
  bronzeSword: { name: 'ブロンズソード', atk: 2, type: 'weapon', cost: 30 },
  ironLance:   { name: 'アイアンランス', atk: 4, type: 'weapon', cost: 60 },
  battleAxe:   { name: 'バトルアックス', atk: 6, type: 'weapon', cost: 90 },
  mageStaff:  { name: 'メイジスタッフ', atk: 2, type: 'weapon', mpBoost: 5, cost: 50 }
};

// モンスターの定義。名前、HP、攻撃力、防御力、経験値、ゴールド、出現確率、使う呪文など。
const MONSTERS = [
  {
    id: 'slime',
    name: 'スライム',
    maxHp: 10,
    atk: 3,
    def: 1,
    exp: 5,
    gold: 3,
    image: 'slime',
    spells: []
  },
  {
    id: 'bat',
    name: 'こうもり',
    maxHp: 12,
    atk: 4,
    def: 1,
    exp: 7,
    gold: 4,
    image: 'bat',
    spells: []
  },
  {
    id: 'skeleton',
    name: 'スケルトン',
    maxHp: 20,
    atk: 6,
    def: 3,
    exp: 15,
    gold: 10,
    image: 'skeleton',
    spells: ['fire']
  },
  {
    id: 'orc',
    name: 'オーク',
    maxHp: 26,
    atk: 8,
    def: 4,
    exp: 18,
    gold: 12,
    image: 'orc',
    spells: []
  },
  {
    id: 'dragon',
    name: 'ドラゴン',
    maxHp: 40,
    atk: 10,
    def: 6,
    exp: 30,
    gold: 25,
    image: 'dragon',
    spells: ['fireball','blizzard','thunder']
  },
  {
    id: 'mage_monster',
    name: 'まどうし',
    maxHp: 24,
    atk: 5,
    def: 3,
    exp: 20,
    gold: 18,
    image: 'mage_monster',
    spells: ['fire','ice','heal']
  },
  {
    id: 'fenrir',
    name: 'フェンリル',
    maxHp: 28,
    atk: 9,
    def: 4,
    exp: 22,
    gold: 16,
    image: 'fenrir',
    spells: []
  },
  {
    id: 'seacreature',
    name: 'さかなまじん',
    maxHp: 30,
    atk: 7,
    def: 5,
    exp: 24,
    gold: 18,
    image: 'seacreature',
    spells: ['ice']
  },
  {
    id: 'minotaur',
    name: 'ミノタウロス',
    maxHp: 32,
    atk: 9,
    def: 5,
    exp: 28,
    gold: 20,
    image: 'minotaur',
    spells: []
  },
  {
    id: 'ghost',
    name: 'ゴースト',
    maxHp: 18,
    atk: 5,
    def: 2,
    exp: 14,
    gold: 9,
    image: 'ghost',
    spells: ['blizzard']
  },
  // ラスボス: 魔王
  {
    id: 'darklord',
    name: 'まおう',
    maxHp: 120,
    atk: 12,
    def: 8,
    exp: 0,
    gold: 0,
    image: 'dragon',
    spells: ['fireball','blizzard','thunder','healall']
  }
];

// 職業（クラス）の定義。
const CLASSES = [
  {
    id: 0,
    name: 'せんし',
    desc: '高いHPと攻撃力を持つ近接戦士。',
    base: { hp: 30, mp: 5, atk: 5, def: 4 },
    growth: { hp: 5, mp: 1, atk: 2, def: 2 },
    spells: []
  },
  {
    id: 1,
    name: 'まほうつかい',
    desc: 'MPと攻撃魔法が得意だがHPが低い。',
    base: { hp: 18, mp: 20, atk: 2, def: 2 },
    growth: { hp: 3, mp: 4, atk: 1, def: 1 },
    spells: ['fire','ice','heal']
  },
  {
    id: 2,
    name: 'そうりょ',
    desc: '回復と支援に長けるヒーラー。',
    base: { hp: 24, mp: 16, atk: 2, def: 3 },
    growth: { hp: 4, mp: 3, atk: 1, def: 1 },
    spells: ['heal','cure','protect']
  },
  {
    id: 3,
    name: 'しょうにん',
    desc: 'お金を稼ぐのが得意なクラス。',
    base: { hp: 26, mp: 8, atk: 3, def: 3 },
    growth: { hp: 4, mp: 2, atk: 1, def: 1 },
    spells: ['heal'],
    bonusGold: 0.5
  },
  {
    id: 4,
    name: 'とうぞく',
    desc: '素早さとアイテムドロップ率が高い。',
    base: { hp: 22, mp: 10, atk: 4, def: 2 },
    growth: { hp: 3, mp: 2, atk: 2, def: 1 },
    spells: ['fire'],
    dropRate: 0.3
  },
  {
    id: 5,
    name: 'あそびにん',
    desc: '成長は遅いが運が良い。',
    base: { hp: 20, mp: 8, atk: 3, def: 2 },
    growth: { hp: 2, mp: 1, atk: 1, def: 1 },
    spells: ['heal'],
    luck: 5
  }
];

// レベルアップに必要な経験値テーブル（簡易版）
const LEVEL_TABLE = [0, 10, 30, 60, 100, 150, 210, 280, 360, 450];

// ワールドタイル種別の列挙
const TILE = {
  GRASS: 0,
  FOREST: 1,
  WATER: 2,
  MOUNTAIN: 3,
  ROAD: 4,
  TOWN: 5,
  INN: 6,
  NPC: 7,
  DESERT: 8,
  SWAMP: 9,
  CASTLE: 10,
  SHOP: 11,
  TEMPLE: 12,
  SHIP: 13,
  AIRSHIP: 14
  ,
  // 新しいタイル: ポータル。別の世界への入口として機能する。
  PORTAL: 15
};

// タイルごとのプロパティ（歩行可能か、遭遇率など）
const TILE_PROPERTIES = {
  [TILE.GRASS]:  { walkable: true,  encounter: 0.03 },
  [TILE.FOREST]: { walkable: true,  encounter: 0.06 },
  [TILE.WATER]:  { walkable: false, encounter: 0 },
  [TILE.MOUNTAIN]: { walkable: false, encounter: 0 },
  [TILE.ROAD]:   { walkable: true,  encounter: 0.01 },
  [TILE.TOWN]:   { walkable: true,  encounter: 0 },
  [TILE.INN]:    { walkable: true,  encounter: 0 },
  [TILE.NPC]:    { walkable: true,  encounter: 0 },
  [TILE.DESERT]: { walkable: true,  encounter: 0.07 },
  [TILE.SWAMP]:  { walkable: true,  encounter: 0.08 },
  [TILE.CASTLE]: { walkable: true,  encounter: 0 },
  [TILE.SHOP]:   { walkable: true,  encounter: 0 },
  [TILE.TEMPLE]: { walkable: true,  encounter: 0 },
  [TILE.SHIP]:   { walkable: true,  encounter: 0 },
  [TILE.AIRSHIP]: { walkable: true, encounter: 0 }
  ,
  // ポータルは歩行可能でエンカウントなし。踏むと別のマップへ移動する。
  [TILE.PORTAL]: { walkable: true, encounter: 0 }
};

// タイルとアセットの名前対応（assets.jsで使用）
const TILE_NAMES = {
  [TILE.GRASS]: 'grass',
  [TILE.FOREST]: 'forest',
  [TILE.WATER]: 'water',
  [TILE.MOUNTAIN]: 'mountain',
  [TILE.ROAD]: 'road',
  [TILE.TOWN]: 'town',
  [TILE.INN]: 'inn',
  [TILE.NPC]: 'npc',
  [TILE.DESERT]: 'desert',
  [TILE.SWAMP]: 'swamp',
  [TILE.CASTLE]: 'castle',
  [TILE.SHOP]: 'shop',
  [TILE.TEMPLE]: 'temple',
  [TILE.SHIP]: 'ship',
  [TILE.AIRSHIP]: 'airship'
  ,
  // ポータルは寺院のグラフィックを再利用します
  [TILE.PORTAL]: 'temple'
};// audio.js
// WebAudio API を用いた簡単なサウンド生成。

class AudioManager {
  constructor() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    // BGM 再生用の設定
    this.currentOscillators = [];
    this.bgmTimeout = null;
    this.currentTuneName = null;
    // シンプルなメロディ定義。各要素は { freq: 周波数, duration: 再生時間(秒) }。
    // More elaborate tunes inspired by classic RPG melodies. Each tune contains a longer sequence of notes.
    this.tunes = {
      // Title theme: uplifting arpeggio reminiscent of the opening fanfare
      title: [
        { freq: 659, duration: 0.3 }, // E5
        { freq: 784, duration: 0.3 }, // G5
        { freq: 880, duration: 0.3 }, // A5
        { freq: 988, duration: 0.3 }, // B5
        { freq: 1047, duration: 0.4 }, // C6
        { freq: 880, duration: 0.3 }, // A5
        { freq: 784, duration: 0.3 }, // G5
        { freq: 659, duration: 0.4 }, // E5
        { freq: 523, duration: 0.5 } // C5
      ],
      // Field theme: gentle flowing melody
      field: [
        { freq: 440, duration: 0.4 }, // A4
        { freq: 494, duration: 0.4 }, // B4
        { freq: 523, duration: 0.4 }, // C5
        { freq: 587, duration: 0.4 }, // D5
        { freq: 659, duration: 0.4 }, // E5
        { freq: 587, duration: 0.4 }, // D5
        { freq: 523, duration: 0.4 }, // C5
        { freq: 494, duration: 0.4 }, // B4
        { freq: 440, duration: 0.8 }  // A4
      ],
      // Battle theme: energetic and tense
      battle: [
        { freq: 392, duration: 0.3 }, // G4
        { freq: 440, duration: 0.3 }, // A4
        { freq: 494, duration: 0.3 }, // B4
        { freq: 523, duration: 0.3 }, // C5
        { freq: 587, duration: 0.3 }, // D5
        { freq: 494, duration: 0.3 }, // B4
        { freq: 440, duration: 0.3 }, // A4
        { freq: 392, duration: 0.6 }, // G4
        { freq: 330, duration: 0.6 }  // E4
      ],
      // Victory jingle: short triumphant sequence
      victory: [
        { freq: 523, duration: 0.4 }, // C5
        { freq: 659, duration: 0.4 }, // E5
        { freq: 784, duration: 0.4 }, // G5
        { freq: 880, duration: 0.6 }, // A5
        { freq: 988, duration: 0.5 }, // B5
        { freq: 784, duration: 0.5 }, // G5
        { freq: 659, duration: 0.6 }, // E5
        { freq: 523, duration: 0.8 }  // C5
      ]
    };
  }

  /**
   * ビープ音を再生します。
   * @param {number} freq 周波数（Hz）
   * @param {number} duration 再生時間（秒）
   */
  beep(freq = 440, duration = 0.1) {
    try {
      // オーディオコンテキストが停止している場合は再開する
      if (this.ctx.state === 'suspended') {
        // resume() は Promise を返すが非同期でも問題ない
        this.ctx.resume().catch(() => {});
      }
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.frequency.value = freq;
      osc.type = 'square';
      osc.connect(gain);
      gain.connect(this.ctx.destination);
      gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
      osc.start();
      osc.stop(this.ctx.currentTime + duration);
    } catch (e) {
      // オーディオコンテキストの制約でエラーになる場合は無視
    }
  }

  /**
   * 指定したメロディをループ再生します。別のBGMが再生中の場合は停止してから開始します。
   * @param {string} name メロディ名 (title, field, battle, victory)
   */
  playBgm(name) {
    if (!this.tunes[name]) return;
    // すでに同じ曲が鳴っている場合は何もしない
    if (this.currentTuneName === name) return;
    this.stopBgm();
    this.currentTuneName = name;
    // オーディオコンテキストが停止している場合は再開する
    if (this.ctx.state === 'suspended') {
      this.ctx.resume().catch(() => {});
    }
    const notes = this.tunes[name];
    const playSequence = () => {
      let startTime = this.ctx.currentTime;
      // スケジュール
      notes.forEach(note => {
        try {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.frequency.value = note.freq;
          osc.type = 'square';
          osc.connect(gain);
          gain.connect(this.ctx.destination);
          gain.gain.setValueAtTime(0.05, startTime);
          gain.gain.exponentialRampToValueAtTime(0.001, startTime + note.duration);
          osc.start(startTime);
          osc.stop(startTime + note.duration);
          this.currentOscillators.push(osc);
        } catch (e) {
          // オーディオコンテキストの制約でエラーになる場合は無視
        }
        startTime += note.duration;
      });
      // 次のループをスケジュール
      this.bgmTimeout = setTimeout(playSequence, notes.reduce((sum, n) => sum + n.duration, 0) * 1000);
    };
    playSequence();
  }

  /**
   * BGMを停止します。
   */
  stopBgm() {
    // 停止
    if (this.bgmTimeout) {
      clearTimeout(this.bgmTimeout);
      this.bgmTimeout = null;
    }
    this.currentTuneName = null;
    // 既存のオシレーターを停止
    this.currentOscillators.forEach(osc => {
      try {
        osc.stop();
      } catch (e) {
        // ignore
      }
    });
    this.currentOscillators = [];
  }
}

const audioManager = new AudioManager();// world.js
// ワールドの地形生成と関連する処理を提供します。


/**
 * ランダムなワールドを生成します。
 * 64x64 のタイルマップで、草原や森、山、水面などを配置します。
 * また、町や城、寺院などを定位置に設置します。
 * 戻り値は { map, startX, startY, towns, temples } のようなオブジェクトです。
 */
function generateWorld() {
  /**
   * 二つのマップを生成して返します。マップは256×256サイズで、
   * それぞれ独立した地形や施設を持ちます。ポータルタイルを
   * 各マップに1つ配置し、踏むともう片方のマップへワープします。
   * 戻り値は以下のプロパティを持ちます:
   * - maps: [map0, map1] 二つの2次元配列
   * - map: 現在使用中のマップへの参照
   * - currentMapIndex: 現在のマップインデックス(0 または 1)
   * - startX, startY: 初期座標
   * - portalPairs: ポータルの位置ペア配列
   * - その他: towns, temples, castle, ship, airship
   */
  const size = 256;

  // ヘルパー関数: 単一のマップを生成
  function createMap() {
    const map = Array.from({ length: size }, () => Array(size).fill(TILE.GRASS));
    const towns = [];
    const temples = [];
    const shops = [];
    const inns = [];
    // 地形生成: ランダムに水・山・森・沼・砂漠を配置
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const r = Math.random();
        if (r < 0.05) map[y][x] = TILE.WATER;
        else if (r < 0.10) map[y][x] = TILE.MOUNTAIN;
        else if (r < 0.20) map[y][x] = TILE.FOREST;
        else if (r < 0.25) map[y][x] = TILE.SWAMP;
        else if (r < 0.30) map[y][x] = TILE.DESERT;
      }
    }
    // 主要な町を8箇所ランダムに配置（等間隔に散らす）
    const townPositions = [];
    const positions = [32, 96, 160, 224];
    positions.forEach(px => {
      positions.forEach(py => {
        townPositions.push({ x: px, y: py });
      });
    });
    // シャッフルして4つだけ町にする
    while (townPositions.length > 8) townPositions.splice(Math.floor(Math.random() * townPositions.length), 1);
    townPositions.forEach(pos => {
      map[pos.y][pos.x] = TILE.TOWN;
      towns.push(pos);
      // 周囲を道路で囲む
      for (let dx = -2; dx <= 2; dx++) {
        for (let dy = -2; dy <= 2; dy++) {
          const nx = pos.x + dx;
          const ny = pos.y + dy;
          if (nx >= 0 && ny >= 0 && nx < size && ny < size) {
            if (map[ny][nx] === TILE.GRASS) map[ny][nx] = TILE.ROAD;
          }
        }
      }
    });
    // 宿屋・ショップを町の周辺に配置
    towns.forEach(pos => {
      const innPos = { x: pos.x + 1, y: pos.y + 2 };
      if (innPos.x < size && innPos.y < size) {
        map[innPos.y][innPos.x] = TILE.INN;
        inns.push(innPos);
      }
    });
    towns.forEach(pos => {
      const shopPos = { x: pos.x - 2, y: pos.y + 2 };
      if (shopPos.x >= 0 && shopPos.y < size) {
        map[shopPos.y][shopPos.x] = TILE.SHOP;
        shops.push(shopPos);
      }
    });
    // 寺院を数ヶ所設置
    const templePositions = [
      { x: 40, y: 20 }, { x: 20, y: 40 }, { x: 216, y: 40 }, { x: 40, y: 216 }, { x: 120, y: 120 }, { x: 200, y: 200 }
    ];
    templePositions.forEach(pos => {
      map[pos.y][pos.x] = TILE.TEMPLE;
      temples.push(pos);
    });
    // 城を中央に配置
    const castle = { x: Math.floor(size / 2), y: Math.floor(size / 2) };
    map[castle.y][castle.x] = TILE.CASTLE;
    // 船を海の近くに配置
    const ship = { x: 3, y: 10 };
    map[ship.y][ship.x] = TILE.SHIP;
    // エアシップを遠くに配置
    const airship = { x: size - 10, y: size - 20 };
    map[airship.y][airship.x] = TILE.AIRSHIP;
    // NPC看板を町の北側に配置
    towns.forEach(pos => {
      const npcPos = { x: pos.x, y: pos.y - 2 };
      if (npcPos.y >= 0) map[npcPos.y][npcPos.x] = TILE.NPC;
    });
    // 城から町へ道路を敷く
    towns.forEach(pos => {
      let x = castle.x;
      let y = castle.y;
      while (x !== pos.x || y !== pos.y) {
        if (map[y][x] === TILE.GRASS) map[y][x] = TILE.ROAD;
        if (x < pos.x) x++;
        else if (x > pos.x) x--;
        if (map[y][x] === TILE.GRASS) map[y][x] = TILE.ROAD;
        if (y < pos.y) y++;
        else if (y > pos.y) y--;
      }
    });
    return { map, towns, temples, shops, inns, castle, ship, airship };
  }

  // 2つのマップを生成
  const m0 = createMap();
  const m1 = createMap();

  // ポータルの位置を決める
  const portal0 = { x: 16, y: 16 };
  const portal1 = { x: size - 17, y: size - 17 };
  // マップにポータルを配置
  m0.map[portal0.y][portal0.x] = TILE.PORTAL;
  m1.map[portal1.y][portal1.x] = TILE.PORTAL;
  // スタート位置はマップ0の城の下
  const startX = m0.castle.x;
  const startY = m0.castle.y + 1;
  return {
    maps: [m0.map, m1.map],
    map: m0.map,
    currentMapIndex: 0,
    startX,
    startY,
    towns: m0.towns.concat(m1.towns),
    temples: m0.temples.concat(m1.temples),
    castle: m0.castle,
    ship: m0.ship,
    airship: m0.airship,
    portalPairs: [
      { from: { map: 0, x: portal0.x, y: portal0.y }, to: { map: 1, x: portal1.x, y: portal1.y } },
      { from: { map: 1, x: portal1.x, y: portal1.y }, to: { map: 0, x: portal0.x, y: portal0.y } }
    ]
  };
}

// マップ上の移動可能性チェック
function canWalk(map, x, y) {
  if (y < 0 || y >= map.length || x < 0 || x >= map[0].length) return false;
  const tile = map[y][x];
  return TILE_PROPERTIES[tile].walkable;
}// entities.js
// プレイヤーやモンスターなどのゲーム内キャラクターのクラスを定義します。



// バフ情報を表すクラス
class Buff {
  constructor(stat, amount, duration) {
    this.stat = stat;
    this.amount = amount;
    this.duration = duration; // 戦闘ターン数
  }
  tick() {
    this.duration--;
  }
  isExpired() {
    return this.duration <= 0;
  }
}

// プレイヤーキャラクター
class Player {
  constructor(classId) {
    const cls = CLASSES[classId];
    this.classId = classId;
    this.name = cls.name;
    this.level = 1;
    this.exp = 0;
    this.hp = cls.base.hp;
    this.maxHp = cls.base.hp;
    this.mp = cls.base.mp;
    this.maxMp = cls.base.mp;
    this.atk = cls.base.atk;
    this.def = cls.base.def;
    this.spells = [...cls.spells];
    this.inventory = { potion: 1, ether: 1, antidote: 0, herb: 0, atkSeed: 0, defSeed: 0, barrier: 0 };
    this.gold = 0;
    this.buffs = [];
    this.poison = false;
    this.orbs = 0;
    this.questStage = 0;
    this.hasShip = false;
    this.hasAirship = false;
    // flags for battle buff resets
    // 装備中の武器キー（なしの場合は null）
    this.weapon = null;
    // ラスボス討伐フラグ
    this.finalBossDefeated = false;
  }

  // 現在の攻撃力・防御力（バフ込み）
  get atkTotal() {
    let bonus = 0;
    this.buffs.forEach(b => {
      if (b.stat === 'atk') bonus += b.amount;
    });
    // 武器攻撃力を加算
    const weaponAtk = this.weapon && ITEMS[this.weapon] && ITEMS[this.weapon].atk ? ITEMS[this.weapon].atk : 0;
    return this.atk + weaponAtk + bonus;
  }
  get defTotal() {
    let bonus = 0;
    this.buffs.forEach(b => {
      if (b.stat === 'def') bonus += b.amount;
    });
    return this.def + bonus;
  }

  // MP増加バフ合計
  get mpBuffAmount() {
    let bonus = 0;
    this.buffs.forEach(b => {
      if (b.stat === 'mp') bonus += b.amount;
    });
    return bonus;
  }

  // 現在の最大MP（バフ・装備込み）
  get maxMpTotal() {
    const weaponBoost = this.weapon && ITEMS[this.weapon] && ITEMS[this.weapon].mpBoost ? ITEMS[this.weapon].mpBoost : 0;
    return this.maxMp + weaponBoost + this.mpBuffAmount;
  }
  // レベルアップ処理
  levelUp() {
    const cls = CLASSES[this.classId];
    this.level++;
    this.maxHp += cls.growth.hp;
    this.maxMp += cls.growth.mp;
    this.atk += cls.growth.atk;
    this.def += cls.growth.def;
    this.hp = this.maxHp;
    this.mp = this.maxMp;
  }
  // 経験値を加算しレベルアップチェック
  addExp(amount) {
    this.exp += amount;
    while (this.level < LEVEL_TABLE.length && this.exp >= LEVEL_TABLE[this.level]) {
      this.levelUp();
    }
  }
  // ゴールド加算
  addGold(amount) {
    // merchant bonus
    const cls = CLASSES[this.classId];
    let bonus = amount;
    if (cls.bonusGold) bonus += amount * cls.bonusGold;
    this.gold += Math.floor(bonus);
  }
  // ダメージを受ける
  takeDamage(amount) {
    this.hp -= amount;
    if (this.hp < 0) this.hp = 0;
  }
  // 回復
  heal(amount) {
    this.hp += amount;
    if (this.hp > this.maxHp) this.hp = this.maxHp;
  }
  // MP回復
  restoreMp(amount) {
    this.mp += amount;
    // 武器やバフ込みの最大MPで上限
    const maxMp = this.maxMpTotal;
    if (this.mp > maxMp) this.mp = maxMp;
  }
  // 状態異常解除
  curePoison() {
    this.poison = false;
  }
  // バフの追加
  applyBuff(buff) {
    this.buffs.push(new Buff(buff.stat, buff.amount, buff.duration));
  }
  // 戦闘中に呼ばれる：バフの減衰処理
  tickBuffs() {
    this.buffs.forEach(b => b.tick());
    this.buffs = this.buffs.filter(b => !b.isExpired());
  }
  // アイテム使用
  useItem(key) {
    const item = ITEMS[key];
    if (!item || this.inventory[key] <= 0) return { message: 'アイテムがありません' };
    // consume
    this.inventory[key]--;
    let message = '';
    // 武器の場合は装備する
    if (item.type === 'weapon') {
      this.weapon = key;
      message = `${item.name}を装備した！`;
      // mpブーストがある武器の場合、現在MPの回復上限も調整
      // 現在MPが新しい最大MPを超えないよう調整
      const maxMp = this.maxMpTotal;
      if (this.mp > maxMp) this.mp = maxMp;
      return { message };
    }
    if (item.heal) {
      this.heal(item.heal);
      message = `${item.name}で${item.heal}回復した！`;
    }
    if (item.mpHeal) {
      this.restoreMp(item.mpHeal);
      message = `${item.name}でMPが${item.mpHeal}回復した！`;
    }
    if (item.curePoison) {
      this.curePoison();
      message = `${item.name}で毒が治った！`;
    }
    if (item.buff) {
      this.applyBuff(item.buff);
      message = `${item.name}で${item.buff.stat.toUpperCase()}が上がった！`;
    }
    return { message };
  }
  // 呪文使用
  castSpell(spellKey, target) {
    const spell = SPELLS[spellKey];
    if (!spell) return { message: '呪文を知らない' };
    if (this.mp < spell.mp) return { message: 'MPが足りない！' };
    this.mp -= spell.mp;
    let message = '';
    if (spell.type === 'attack') {
      const dmg = spell.power + Math.floor(Math.random() * 4);
      target.takeDamage(dmg);
      message = `${spell.name}を唱えた！敵に${dmg}のダメージ！`;
    } else if (spell.type === 'heal') {
      this.heal(spell.power === 999 ? this.maxHp : spell.power);
      message = `${spell.name}で回復した！`;
    } else if (spell.type === 'buff') {
      this.applyBuff({ stat: spell.stat, amount: spell.amount, duration: spell.duration });
      message = `${spell.name}で${spell.stat.toUpperCase()}を上げた！`;
    }
    return { message };
  }
}

// 敵モンスター
class Monster {
  constructor(def) {
    this.id = def.id;
    this.name = def.name;
    this.maxHp = def.maxHp;
    this.hp = def.maxHp;
    this.atk = def.atk;
    this.def = def.def;
    this.exp = def.exp;
    this.gold = def.gold;
    this.spells = def.spells || [];
    this.image = def.image;
  }
  isAlive() {
    return this.hp > 0;
  }
  takeDamage(amount) {
    this.hp -= amount;
    if (this.hp < 0) this.hp = 0;
  }
}// scenes.js
// さまざまなシーン（タイトル、クラス選択、フィールド、戦闘など）を定義します。






// ユーティリティ：文字列を行単位に折り返す
function wrapText(text, width) {
  const words = text.split(/\s+/);
  let lines = [];
  let current = '';
  words.forEach(word => {
    if ((current + word).length > width) {
      lines.push(current.trim());
      current = word + ' ';
    } else {
      current += word + ' ';
    }
  });
  if (current.trim()) lines.push(current.trim());
  return lines;
}

// 基底シーン
class Scene {
  constructor(game) {
    this.game = game;
  }
  update(dt) {}
  draw(ctx) {}
  onKeyDown(key) {}
}

// 安全にlocalStorageへアクセスするユーティリティ
function safeGet(key) {
  try {
    return window.localStorage ? localStorage.getItem(key) : null;
  } catch (e) {
    return null;
  }
}
function safeSet(key, value) {
  try {
    if (window.localStorage) localStorage.setItem(key, value);
  } catch (e) {
    // ignore
  }
}

// タイトルシーン
class TitleScene extends Scene {
  constructor(game) {
    super(game);
    this.options = ['ニューゲーム', 'つづきから'];
    this.selected = 0;
    // タイトル画面ではBGMはユーザー操作後に再生します
    audioManager.stopBgm();
  }
  update(dt) {
    // 初めての入力でタイトルBGMを開始
    if (!audioManager.currentTuneName && Object.keys(this.game.keysDown).length > 0) {
      audioManager.playBgm('title');
    }
    // 入力処理
    if (this.game.isKeyJustPressed('ArrowUp')) {
      audioManager.beep(660, 0.05);
      this.selected = (this.selected + this.options.length - 1) % this.options.length;
    }
    if (this.game.isKeyJustPressed('ArrowDown')) {
      audioManager.beep(660, 0.05);
      this.selected = (this.selected + 1) % this.options.length;
    }
    if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
      audioManager.beep(880, 0.1);
      const choice = this.options[this.selected];
      if (choice === 'ニューゲーム') {
        this.game.replaceScene(new ClassSelectionScene(this.game));
      } else if (choice === 'つづきから') {
        const saved = safeGet('sfc_rpg_save');
        if (saved) {
          const data = JSON.parse(saved);
          const player = Object.assign(new Player(0), data.player);
          // restore dynamic fields like buffs as empty
          player.buffs = [];
          this.game.replaceScene(new FieldScene(this.game, data.world, player));
        }
      }
    }
  }
  draw(ctx) {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, this.game.width, this.game.height);
    ctx.fillStyle = '#fff';
    ctx.font = '20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SFC風RPG Pixel', this.game.width / 2, 60);
    ctx.font = '14px monospace';
    this.options.forEach((opt, i) => {
      ctx.fillStyle = i === this.selected ? '#ff0' : '#fff';
      ctx.fillText(opt, this.game.width / 2, 120 + i * 24);
    });
    // セーブデータが無ければ続きからをグレーアウト
    const saved = safeGet('sfc_rpg_save');
    if (!saved) {
      ctx.fillStyle = '#555';
      ctx.fillText('つづきから', this.game.width / 2, 120 + 1 * 24);
    }

    // 操作方法を画面下部に表示してプレイヤーにガイドを提供
    ctx.font = '10px monospace';
    ctx.fillStyle = '#888';
    ctx.textAlign = 'center';
    ctx.fillText('矢印キー: 移動    Z/Enter: 決定    X/Esc: キャンセル    M: メニュー', this.game.width / 2, this.game.height - 10);
  }
}

// クラス選択シーン
class ClassSelectionScene extends Scene {
  constructor(game) {
    super(game);
    this.selected = 0;
  }
  update(dt) {
    if (this.game.isKeyJustPressed('ArrowUp')) {
      audioManager.beep(660, 0.05);
      this.selected = (this.selected + CLASSES.length - 1) % CLASSES.length;
    }
    if (this.game.isKeyJustPressed('ArrowDown')) {
      audioManager.beep(660, 0.05);
      this.selected = (this.selected + 1) % CLASSES.length;
    }
    if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
      audioManager.beep(880, 0.1);
      const clsId = this.selected;
      const player = new Player(clsId);
      const world = generateWorld();
      this.game.replaceScene(new FieldScene(this.game, world, player));
    }
  }
  draw(ctx) {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, this.game.width, this.game.height);
    ctx.fillStyle = '#fff';
    ctx.font = '18px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('職業を選んでください', this.game.width / 2, 40);
    ctx.font = '14px monospace';
    CLASSES.forEach((cls, i) => {
      ctx.fillStyle = i === this.selected ? '#ff0' : '#fff';
      ctx.fillText(`${cls.name}`, this.game.width / 2, 80 + i * 20);
    });
    // 説明文
    const desc = CLASSES[this.selected].desc;
    ctx.fillStyle = '#ccc';
    ctx.font = '12px monospace';
    ctx.textAlign = 'left';
    const lines = wrapText(desc, 20);
    lines.forEach((line, j) => {
      ctx.fillText(line, 20, 180 + j * 16);
    });
  }
}

// 汎用ウィンドウ描画関数。DQ3風に濃い背景と白枠で描画します。
function drawWindow(ctx, x, y, w, h) {
  // 背景をやや透過の黒で塗る
  ctx.fillStyle = 'rgba(0,0,0,0.9)';
  ctx.fillRect(x, y, w, h);
  // 白枠を太めに描く
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.strokeRect(x + 1, y + 1, w - 2, h - 2);
  // 内側に薄い枠を描き込むことでSFC風の立体感を出す
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 3, y + 3, w - 6, h - 6);
}

// メッセージ表示ユーティリティ：下部のウィンドウにテキストを表示
function drawMessageWindow(ctx, message) {
  const width = ctx.canvas.width;
  const height = ctx.canvas.height;
  const lines = wrapText(message, 30);
  // ウィンドウ高さは行数に応じて調整（最低2行分）
  const winH = Math.max(32 + lines.length * 16, 48);
  drawWindow(ctx, 0, height - winH, width, winH);
  ctx.fillStyle = '#fff';
  ctx.font = '12px monospace';
  ctx.textAlign = 'left';
  lines.forEach((line, i) => {
    ctx.fillText(line, 4, height - winH + 16 + i * 16);
  });
}

// フィールドシーン
class FieldScene extends Scene {
  constructor(game, world, player) {
    super(game);
    this.world = world;
    this.player = player;
    this.x = world.startX;
    this.y = world.startY;
    this.timeCount = 0;
    // 一日の長さ（歩数ベース）
    this.dayLength = 200;
    this.message = null;
    this.showingMessage = false;
    this.messageTimer = 0;
    // アニメーション用フレームカウンタ：0=立ち、1=歩行
    this.walkFrame = 0;
    // フィールドBGMを開始
    audioManager.stopBgm();
    audioManager.playBgm('field');
  }
  update(dt) {
    // フィールドBGMが止まっている場合は再開（戦闘から戻ったとき）
    if (audioManager.currentTuneName !== 'field') {
      audioManager.playBgm('field');
    }
    // メッセージ表示中はボタンで閉じる
    if (this.showingMessage) {
      if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
        this.showingMessage = false;
        this.message = null;
      }
      return;
    }
    // 毒状態で歩く度にダメージ
    if (this.player.poison) {
      this.player.takeDamage(1);
    }
    // 移動
    let moved = false;
    let nx = this.x;
    let ny = this.y;
    if (this.game.isKeyJustPressed('ArrowLeft')) { nx--; moved = true; }
    if (this.game.isKeyJustPressed('ArrowRight')) { nx++; moved = true; }
    if (this.game.isKeyJustPressed('ArrowUp')) { ny--; moved = true; }
    if (this.game.isKeyJustPressed('ArrowDown')) { ny++; moved = true; }
    if (moved) {
      if (canWalk(this.world.map, nx, ny) || this.player.hasShip || this.player.hasAirship) {
        this.x = nx;
        this.y = ny;
        audioManager.beep(440, 0.05);
        this.timeCount++;
        // 移動したらフレームを切り替え
        this.walkFrame = 1 - this.walkFrame;
        // ランダムエンカウント
        const tile = this.world.map[this.y][this.x];
        // ポータルの上ではエンカウントせず、マップ切替処理を行う
        if (tile === TILE.PORTAL) {
          // 現在位置に対応するポータルペアを検索
          const pair = this.world.portalPairs.find(p => p.from.map === this.world.currentMapIndex && p.from.x === this.x && p.from.y === this.y);
          if (pair) {
            // ワールド情報更新
            this.world.currentMapIndex = pair.to.map;
            this.world.map = this.world.maps[pair.to.map];
            // 新しい座標に移動
            this.x = pair.to.x;
            this.y = pair.to.y;
            // メッセージ表示
            this.showMessage('別の世界へワープした！');
            return;
          }
        }
        // 船・飛行機の場合は遭遇率低減
        let rate = TILE_PROPERTIES[tile].encounter;
        // 夜は遭遇率増加
        if (this.isNight()) rate *= 1.5;
        if (this.player.hasAirship) rate = 0; // 空飛ぶ乗り物ではエンカウント無し
        if (Math.random() < rate) {
          // 適当なモンスターを生成
          const def = MONSTERS[Math.floor(Math.random() * MONSTERS.length)];
          const monster = new Monster(def);
          this.game.pushScene(new BattleScene(this.game, this.player, monster));
          return;
        }
        // イベント処理
        this.handleTileEvent(tile);
      }
    }
    // メニュー
    if (this.game.isKeyJustPressed('Escape') || this.game.isKeyJustPressed('KeyM')) {
      this.game.pushScene(new MenuScene(this.game, this.player, this.world, this));
    }
  }
  handleTileEvent(tile) {
    switch (tile) {
      case TILE.TOWN:
        this.showMessage('ここは町だ。人々が暮らしている。');
        break;
      case TILE.INN:
        this.showMessage('宿屋に泊まりますか？ HP/MPが全回復します。');
        this.player.heal(this.player.maxHp);
        this.player.restoreMp(this.player.maxMp);
        this.player.curePoison();
        break;
      case TILE.SHOP:
        // 夜は閉店
        if (this.isNight()) {
          this.showMessage('お店は夜閉まっています。朝まで待ちましょう。');
        } else {
          this.game.pushScene(new ShopScene(this.game, this.player));
        }
        break;
      case TILE.TEMPLE:
        this.game.pushScene(new TempleScene(this.game, this.player, this.world));
        break;
      case TILE.CASTLE:
        this.game.pushScene(new CastleScene(this.game, this.player, this.world));
        break;
      case TILE.NPC:
        this.showMessage('道しるべ: 寺院で石を集め、城へ行け！');
        break;
      case TILE.SHIP:
        if (!this.player.hasShip) {
          this.player.hasShip = true;
          this.showMessage('船を手に入れた！水上を移動できる。');
        }
        break;
      case TILE.AIRSHIP:
        if (this.player.orbs >= 6 && !this.player.hasAirship) {
          this.player.hasAirship = true;
          this.showMessage('黄金の鳥を手に入れた！空を飛べる。');
        }
        break;
    }
  }
  // 夜かどうか判定
  isNight() {
    return (this.timeCount % this.dayLength) >= this.dayLength / 2;
  }
  showMessage(msg) {
    this.message = msg;
    this.showingMessage = true;
    this.messageTimer = 0;
  }
  draw(ctx) {
    // 背景
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, this.game.width, this.game.height);
    const tileSize = 16;
    // 描画範囲を計算：プレイヤーを中央に
    const viewW = Math.floor(this.game.width / tileSize);
    const viewH = Math.floor((this.game.height - 32) / tileSize);
    const offsetX = Math.floor(this.x - viewW / 2);
    const offsetY = Math.floor(this.y - viewH / 2);
    for (let vy = 0; vy < viewH; vy++) {
      for (let vx = 0; vx < viewW; vx++) {
        const mx = offsetX + vx;
        const my = offsetY + vy;
        let tile = TILE.GRASS;
        if (my >= 0 && my < this.world.map.length && mx >= 0 && mx < this.world.map[0].length) {
          tile = this.world.map[my][mx];
        }
        const name = TILE_NAMES[tile];
        const img = this.game.assets.tiles[name];
        ctx.drawImage(img, vx * tileSize, vy * tileSize, tileSize, tileSize);
      }
    }
    // プレイヤー描画
    const px = (viewW / 2) * tileSize;
    const py = (viewH / 2) * tileSize;
    // フレームに応じて立ち姿と歩き姿を切り替え
    const heroImg = this.walkFrame === 0 ? this.game.assets.characters.hero : (this.game.assets.characters.hero_walk || this.game.assets.characters.hero);
    ctx.drawImage(heroImg, px, py, tileSize, tileSize);
    // 夜の場合は画面を暗くする
    if (this.isNight()) {
      ctx.fillStyle = 'rgba(0,0,0,0.4)';
      ctx.fillRect(0, 0, this.game.width, this.game.height - 32);
    }
    // HUDを画面上部に表示
    const hudH = 32;
    drawWindow(ctx, 0, 0, this.game.width, hudH);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'left';
    const clsName = CLASSES[this.player.classId].name;
    ctx.fillText(`Lv${this.player.level} ${clsName} HP:${this.player.hp}/${this.player.maxHp} MP:${this.player.mp}/${this.player.maxMp} EXP:${this.player.exp} G:${this.player.gold}`, 4, 20);
    // メッセージ
    if (this.showingMessage && this.message) {
      drawMessageWindow(ctx, this.message);
    }
  }
}

// 戦闘シーン
class BattleScene extends Scene {
  constructor(game, player, monster) {
    super(game);
    this.player = player;
    this.monster = monster;
    this.phase = 'intro';
    this.menuIndex = 0;
    this.messageQueue = [];
    this.turnPlayer = true;
    this.action = null;
    // バトルBGM開始
    audioManager.stopBgm();
    audioManager.playBgm('battle');
  }
  update(dt) {
    // メッセージキューがあれば表示続行
    if (this.messageQueue.length > 0) {
      if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
        this.messageQueue.shift();
      }
      return;
    }
    // 戦闘終了チェック
    if (this.phase !== 'end' && this.phase !== 'gameover') {
      if (!this.monster.isAlive()) {
        // 勝利処理（1回だけ行う）
        this.messageQueue.push(`${this.monster.name}を倒した！`);
        this.player.addExp(this.monster.exp);
        this.player.addGold(this.monster.gold);
        // ドロップ
        const cls = CLASSES[this.player.classId];
        if (cls.dropRate && Math.random() < cls.dropRate) {
          const keys = Object.keys(ITEMS);
          const itemKey = keys[Math.floor(Math.random() * keys.length)];
          this.player.inventory[itemKey] = (this.player.inventory[itemKey] || 0) + 1;
          this.messageQueue.push(`${ITEMS[itemKey].name}を拾った！`);
        }
        // ラスボスの場合は特別なメッセージ
        if (this.monster.id === 'darklord') {
          this.player.finalBossDefeated = true;
          this.messageQueue.push('魔王を倒した！世界に平和が戻った！');
          this.messageQueue.push('エンディング！');
          // エンディングBGM
          audioManager.stopBgm();
          audioManager.playBgm('victory');
        } else {
          this.messageQueue.push('勝利！');
        }
        this.phase = 'end';
      } else if (this.player.hp <= 0) {
        this.messageQueue.push('あなたは倒れてしまった…');
        this.phase = 'gameover';
      }
    }
    switch (this.phase) {
      case 'intro':
        this.messageQueue.push(`${this.monster.name}があらわれた！`);
        this.phase = 'menu';
        break;
      case 'menu':
        // コマンド選択
        if (this.game.isKeyJustPressed('ArrowUp')) {
          audioManager.beep(660, 0.05);
          this.menuIndex = (this.menuIndex + 3) % 4;
        }
        if (this.game.isKeyJustPressed('ArrowDown')) {
          audioManager.beep(660, 0.05);
          this.menuIndex = (this.menuIndex + 1) % 4;
        }
        if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
          audioManager.beep(880, 0.1);
          const option = ['こうげき', 'まほう', 'アイテム', 'にげる'][this.menuIndex];
          if (option === 'こうげき') {
            this.performAttack();
          } else if (option === 'まほう') {
            if (this.player.spells.length === 0) {
              this.messageQueue.push('呪文を覚えていない！');
            } else {
              this.game.pushScene(new MagicSelectScene(this.game, this.player, this.monster, this));
              return;
            }
          } else if (option === 'アイテム') {
            this.game.pushScene(new ItemSelectScene(this.game, this.player, this));
            return;
          } else if (option === 'にげる') {
            if (Math.random() < 0.5) {
              this.messageQueue.push('逃げ出した！');
              this.phase = 'run';
            } else {
              this.messageQueue.push('しかし逃げられなかった！');
              this.turnPlayer = false;
              this.phase = 'enemy';
            }
          }
        }
        break;
      case 'player':
        break;
      case 'enemy':
        // 敵のターン
        const dmg = Math.max(1, this.monster.atk - this.player.defTotal + Math.floor(Math.random() * 3));
        this.player.takeDamage(dmg);
        this.messageQueue.push(`${this.monster.name}の攻撃！${dmg}のダメージ！`);
        // 毒攻撃の確率: snake spawns cause poison sometimes
        if (this.monster.id === 'snake' && Math.random() < 0.2 && !this.player.poison) {
          this.player.poison = true;
          this.messageQueue.push('毒を受けた！歩くとダメージを受ける。');
        }
        // バフ減衰
        this.player.tickBuffs();
        // プレイヤーに戻す
        this.phase = 'menu';
        break;
      case 'run':
        // 逃走成功後、フィールドに戻る
        this.game.popScene();
        break;
      case 'end':
        // 勝利後フィールドに戻る
        this.game.popScene();
        break;
      case 'gameover':
        if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
          this.game.replaceScene(new TitleScene(this.game));
        }
        break;
    }
  }
  performAttack() {
    // プレイヤーの攻撃処理
    const dmg = Math.max(1, this.player.atkTotal - this.monster.def + Math.floor(Math.random() * 3));
    this.monster.takeDamage(dmg);
    this.messageQueue.push(`こうげき！ ${this.monster.name}に${dmg}のダメージ！`);
    // バフ減衰
    this.player.tickBuffs();
    // 次のターンは敵
    this.phase = 'enemy';
  }
  draw(ctx) {
    // 背景
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, this.game.width, this.game.height);
    // 敵スプライト
    const tileSize = 32;
    const img = this.game.assets.monsters[this.monster.image];
    ctx.drawImage(img, (this.game.width - tileSize) / 2, 60, tileSize, tileSize);
    // UI: モンスター名、HPバー
    ctx.fillStyle = '#fff';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${this.monster.name}`, this.game.width / 2, 50);
    // HPバー背景
    ctx.fillStyle = '#444';
    ctx.fillRect(this.game.width / 2 - 50, 70, 100, 8);
    ctx.fillStyle = '#a00';
    const hpW = 100 * (this.monster.hp / this.monster.maxHp);
    ctx.fillRect(this.game.width / 2 - 50, 70, hpW, 8);
    // プレイヤー情報
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'left';
    ctx.fillText(`あなた`, 10, 50);
    ctx.fillText(`HP ${this.player.hp}/${this.player.maxHp}`, 10, 70);
    ctx.fillText(`MP ${this.player.mp}/${this.player.maxMp}`, 10, 90);
    // コマンド
    if (this.phase === 'menu') {
      const options = ['こうげき', 'まほう', 'アイテム', 'にげる'];
      options.forEach((opt, i) => {
        ctx.fillStyle = i === this.menuIndex ? '#ff0' : '#fff';
        ctx.fillText(opt, 10, 130 + i * 20);
      });
    }
    // メッセージウィンドウ
    if (this.messageQueue.length > 0) {
      drawMessageWindow(ctx, this.messageQueue[0]);
    }
    if (this.phase === 'gameover') {
      ctx.fillStyle = '#f00';
      ctx.font = '20px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', this.game.width / 2, this.game.height / 2);
      ctx.font = '12px sans-serif';
      ctx.fillText('Enterでタイトルへ', this.game.width / 2, this.game.height / 2 + 24);
    }
  }
}

// 魔法選択サブシーン
class MagicSelectScene extends Scene {
  constructor(game, player, monster, parent) {
    super(game);
    this.player = player;
    this.monster = monster;
    this.parent = parent;
    this.index = 0;
  }
  update(dt) {
    if (this.game.isKeyJustPressed('ArrowUp')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + this.player.spells.length - 1) % this.player.spells.length;
    }
    if (this.game.isKeyJustPressed('ArrowDown')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + 1) % this.player.spells.length;
    }
    if (this.game.isKeyJustPressed('Escape') || this.game.isKeyJustPressed('Backspace')) {
      this.game.popScene();
      return;
    }
    if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
      const key = this.player.spells[this.index];
      const result = this.player.castSpell(key, this.monster);
      this.parent.messageQueue.push(result.message);
      // バフ減衰
      this.player.tickBuffs();
      // 敵のターン
      this.parent.phase = 'enemy';
      this.game.popScene();
    }
  }
  draw(ctx) {
    this.parent.draw(ctx);
    // オーバーレイウィンドウを描画
    const x = 40;
    const y = 100;
    const w = 176;
    const h = 100;
    drawWindow(ctx, x, y, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('まほう', x + 8, y + 16);
    this.player.spells.forEach((key, i) => {
      const spell = SPELLS[key];
      ctx.fillStyle = i === this.index ? '#ff0' : '#fff';
      ctx.fillText(`${spell.name} MP${spell.mp}`, x + 8, y + 36 + i * 16);
    });
  }
}

// アイテム選択サブシーン
class ItemSelectScene extends Scene {
  constructor(game, player, parent) {
    super(game);
    this.player = player;
    this.parent = parent;
    this.items = Object.keys(ITEMS);
    this.index = 0;
  }
  update(dt) {
    if (this.items.length === 0) {
      this.parent.messageQueue.push('アイテムを持っていない！');
      this.game.popScene();
      return;
    }
    if (this.game.isKeyJustPressed('ArrowUp')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + this.items.length - 1) % this.items.length;
    }
    if (this.game.isKeyJustPressed('ArrowDown')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + 1) % this.items.length;
    }
    if (this.game.isKeyJustPressed('Escape') || this.game.isKeyJustPressed('Backspace')) {
      this.game.popScene();
      return;
    }
    if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
      const key = this.items[this.index];
      if (this.player.inventory[key] > 0) {
        const result = this.player.useItem(key);
        this.parent.messageQueue.push(result.message);
        // バフ減衰
        this.player.tickBuffs();
        // 敵のターン
        this.parent.phase = 'enemy';
        this.game.popScene();
      } else {
        this.parent.messageQueue.push('在庫がない！');
        this.game.popScene();
      }
    }
  }
  draw(ctx) {
    this.parent.draw(ctx);
    const x = 40;
    const y = 100;
    const w = 176;
    const h = 100;
    drawWindow(ctx, x, y, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('アイテム', x + 8, y + 16);
    this.items.forEach((key, i) => {
      const item = ITEMS[key];
      const count = this.player.inventory[key] || 0;
      ctx.fillStyle = i === this.index ? '#ff0' : '#fff';
      ctx.fillText(`${item.name} x${count}`, x + 8, y + 36 + i * 16);
    });
  }
}

// メニューシーン
class MenuScene extends Scene {
  constructor(game, player, world, fieldScene) {
    super(game);
    this.player = player;
    this.world = world;
    this.fieldScene = fieldScene;
    this.options = ['ステータス','アイテム','セーブ','もどる'];
    this.index = 0;
  }
  update(dt) {
    if (this.game.isKeyJustPressed('ArrowUp')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + this.options.length - 1) % this.options.length;
    }
    if (this.game.isKeyJustPressed('ArrowDown')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + 1) % this.options.length;
    }
    if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
      const opt = this.options[this.index];
      audioManager.beep(880, 0.1);
      if (opt === 'ステータス') {
        this.game.pushScene(new StatsScene(this.game, this.player));
      } else if (opt === 'アイテム') {
        this.game.pushScene(new ItemSelectScene(this.game, this.player, this.fieldScene));
      } else if (opt === 'セーブ') {
        const saveData = {
          player: this.player,
          world: this.world
        };
        safeSet('sfc_rpg_save', JSON.stringify(saveData));
        this.fieldScene.showMessage('セーブしました！');
        this.game.popScene();
      } else if (opt === 'もどる') {
        this.game.popScene();
      }
    }
    if (this.game.isKeyJustPressed('Escape')) {
      this.game.popScene();
    }
  }
  draw(ctx) {
    this.fieldScene.draw(ctx);
    const x = 40;
    const y = 80;
    const w = 176;
    const h = 96;
    drawWindow(ctx, x, y, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.fillText('メニュー', x + 8, y + 16);
    this.options.forEach((opt, i) => {
      ctx.fillStyle = i === this.index ? '#ff0' : '#fff';
      ctx.fillText(opt, x + 8, y + 32 + i * 16);
    });
  }
}

// ステータス表示シーン
class StatsScene extends Scene {
  constructor(game, player) {
    super(game);
    this.player = player;
  }
  update(dt) {
    if (this.game.isKeyJustPressed('Escape') || this.game.isKeyJustPressed('Enter')) {
      this.game.popScene();
    }
  }
  draw(ctx) {
    const field = this.game.sceneStack[this.game.sceneStack.length - 2];
    if (field && field.draw) field.draw(ctx);
    const x = 40;
    const y = 80;
    const w = 176;
    const h = 128;
    drawWindow(ctx, x, y, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.fillText('ステータス', x + 8, y + 16);
    const lines = [];
    lines.push(`職業: ${CLASSES[this.player.classId].name}`);
    lines.push(`レベル: ${this.player.level}`);
    lines.push(`経験値: ${this.player.exp}`);
    lines.push(`HP: ${this.player.hp}/${this.player.maxHp}`);
    // 最大MPは装備やバフ込みで表示
    lines.push(`MP: ${this.player.mp}/${this.player.maxMpTotal}`);
    // 攻撃力・防御力は武器とバフ込みの数値を表示
    lines.push(`攻撃力: ${this.player.atkTotal}`);
    lines.push(`防御力: ${this.player.defTotal}`);
    lines.push(`ゴールド: ${this.player.gold}`);
    lines.push(`呪文: ${this.player.spells.map(k => SPELLS[k].name).join('、') || 'なし'}`);
    lines.push(`所持オーブ: ${this.player.orbs}`);
    lines.push(`武器: ${this.player.weapon ? ITEMS[this.player.weapon].name : 'なし'}`);
    lines.forEach((ln, i) => {
      ctx.fillText(ln, x + 8, y + 32 + i * 16);
    });
  }
}

// ショップシーン
class ShopScene extends Scene {
  constructor(game, player) {
    super(game);
    this.player = player;
    this.items = Object.keys(ITEMS);
    this.index = 0;
  }
  update(dt) {
    if (this.game.isKeyJustPressed('ArrowUp')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + this.items.length - 1) % this.items.length;
    }
    if (this.game.isKeyJustPressed('ArrowDown')) {
      audioManager.beep(660, 0.05);
      this.index = (this.index + 1) % this.items.length;
    }
    if (this.game.isKeyJustPressed('Escape') || this.game.isKeyJustPressed('Backspace')) {
      this.game.popScene();
      return;
    }
    if (this.game.isKeyJustPressed('Enter') || this.game.isKeyJustPressed('Space')) {
      const key = this.items[this.index];
      const item = ITEMS[key];
      if (this.player.gold >= item.cost) {
        this.player.gold -= item.cost;
        this.player.inventory[key] = (this.player.inventory[key] || 0) + 1;
        this.game.sceneStack[this.game.sceneStack.length - 2].showMessage(`${item.name}を購入した！`);
      } else {
        this.game.sceneStack[this.game.sceneStack.length - 2].showMessage('お金が足りない！');
      }
      this.game.popScene();
    }
  }
  draw(ctx) {
    const field = this.game.sceneStack[this.game.sceneStack.length - 2];
    field.draw(ctx);
    const x = 32;
    const y = 64;
    const w = 192;
    const h = 160;
    drawWindow(ctx, x, y, w, h);
    ctx.fillStyle = '#fff';
    ctx.font = '12px monospace';
    ctx.fillText('ショップ', x + 8, y + 16);
    this.items.forEach((key, i) => {
      const item = ITEMS[key];
      ctx.fillStyle = i === this.index ? '#ff0' : '#fff';
      ctx.fillText(`${item.name} ${item.cost}G`, x + 8, y + 32 + i * 16);
    });
    ctx.fillStyle = '#ccc';
    ctx.fillText(`所持金: ${this.player.gold}G`, x + 8, y + h - 20);
  }
}

// 寺院シーン
class TempleScene extends Scene {
  constructor(game, player, world) {
    super(game);
    this.player = player;
    this.world = world;
    this.stage = 0;
    // stage 0: 初回セリフ、1: 石受け取り、2: すでに取得済み
  }
  update(dt) {
    // シンプルに：全回復してオーブを入手
    if (this.player.questStage >= 1) {
      if (this.player.orbs < 6) {
        this.player.orbs++;
        this.game.sceneStack[this.game.sceneStack.length - 2].showMessage('精霊石を見つけた！');
      } else {
        this.game.sceneStack[this.game.sceneStack.length - 2].showMessage('祈りが力になる…');
      }
    } else {
      this.game.sceneStack[this.game.sceneStack.length - 2].showMessage('神殿で祈り、力を得た');
    }
    // 全回復
    this.player.heal(this.player.maxHp);
    this.player.restoreMp(this.player.maxMp);
    this.player.curePoison();
    this.game.popScene();
  }
  draw(ctx) {
    const field = this.game.sceneStack[this.game.sceneStack.length - 2];
    field.draw(ctx);
    // ダイアログはイベントが処理するため描画不要
  }
}

// 城シーン
class CastleScene extends Scene {
  constructor(game, player, world) {
    super(game);
    this.player = player;
    this.world = world;
    this.stage = 0;
  }
  update(dt) {
    const fieldScene = this.game.sceneStack[this.game.sceneStack.length - 2];
    // クエスト未開始
    if (this.player.questStage === 0) {
      fieldScene.showMessage('王様: 魔王を倒すため6つの石を集めよ！');
      this.player.questStage = 1;
      this.game.popScene();
      return;
    }
    // 石が揃っていない状態
    if (this.player.questStage === 1 && this.player.orbs >= 6) {
      fieldScene.showMessage('王様: よくぞ石を集めた！伝説の鳥を授けよう。');
      this.player.questStage = 2;
      this.game.popScene();
      return;
    }
    // ラスボス戦の条件：石が6個、飛行機取得済み、まだ討伐していない
    if (this.player.questStage >= 2 && this.player.orbs >= 6 && this.player.hasAirship && !this.player.finalBossDefeated) {
      // ラスボス戦開始
      // 城を抜けてすぐ戦闘
      this.game.popScene();
      const darkDef = MONSTERS.find(m => m.id === 'darklord');
      const boss = new Monster(darkDef);
      this.game.pushScene(new BattleScene(this.game, this.player, boss));
      return;
    }
    // すでに魔王を倒した場合
    if (this.player.finalBossDefeated) {
      fieldScene.showMessage('王様: よくぞ魔王を倒した！世界は平和だ。');
      this.game.popScene();
      return;
    }
    // その他の場合
    fieldScene.showMessage('王様: 旅を急げ！');
    this.game.popScene();
  }
  draw(ctx) {
    const field = this.game.sceneStack[this.game.sceneStack.length - 2];
    field.draw(ctx);
  }
}// game.js
// Game クラス：キャンバスとシーンスタックを管理し、メインループを動かします。



class Game {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.width = canvas.width;
    this.height = canvas.height;
    this.assets = null;
    this.sceneStack = [];
    this.keysDown = {};
    // フェード演出用
    this.fadeAlpha = 0;
    this.fadeSpeed = 1.5; // フェードが1.5秒で終了する速度
    // キーイベント
    window.addEventListener('keydown', e => {
      if (!this.keysDown[e.code]) {
        this.keysDown[e.code] = { pressed: true, just: true };
      }
      // prevent arrow key scrolling
      if ([ 'ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space','Enter' ].includes(e.code)) {
        e.preventDefault();
      }
    });
    window.addEventListener('keyup', e => {
      delete this.keysDown[e.code];
    });
  }
  // 一度だけ呼び出してアセットを読み込む
  async init() {
    this.assets = await loadAssets();
  }
  // メインループ開始
  start() {
    let last = 0;
    const loop = (timestamp) => {
      const dt = (timestamp - last) / 1000;
      last = timestamp;
      this.update(dt);
      this.draw();
      requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }
  // キーが押された瞬間かどうか
  isKeyJustPressed(code) {
    const obj = this.keysDown[code];
    if (obj && obj.just) {
      obj.just = false;
      return true;
    }
    return false;
  }
  // シーン管理
  pushScene(scene) {
    this.sceneStack.push(scene);
    // 新しいシーンを表示するときにフェードイン開始
    this.startFade(1);
  }
  popScene() {
    const removed = this.sceneStack.pop();
    // フェードインを開始
    this.startFade(1);
    return removed;
  }
  replaceScene(scene) {
    this.sceneStack = [scene];
    this.startFade(1);
  }
  /**
   * フェードを開始します。引数はフェード開始時のアルファ値（0〜1）です。
   * @param {number} startAlpha
   */
  startFade(startAlpha = 1) {
    this.fadeAlpha = Math.max(0, Math.min(1, startAlpha));
  }
  update(dt) {
    if (this.sceneStack.length === 0) return;
    const scene = this.sceneStack[this.sceneStack.length - 1];
    if (scene.update) scene.update(dt);
    // フェードアルファを減少
    if (this.fadeAlpha > 0) {
      this.fadeAlpha -= this.fadeSpeed * dt;
      if (this.fadeAlpha < 0) this.fadeAlpha = 0;
    }
  }
  draw() {
    if (this.sceneStack.length === 0) return;
    const scene = this.sceneStack[this.sceneStack.length - 1];
    if (scene.draw) scene.draw(this.ctx);
    // フェードオーバーレイを描画
    if (this.fadeAlpha > 0) {
      this.ctx.save();
      this.ctx.globalAlpha = this.fadeAlpha;
      this.ctx.fillStyle = 'black';
      this.ctx.fillRect(0, 0, this.width, this.height);
      this.ctx.restore();
    }
  }
}// main.js
// エントリーポイント。Gameを初期化し、タイトルシーンをプッシュします。




async function init() {
  const canvas = document.getElementById('gameCanvas');
  const game = new Game(canvas);
  await game.init();
  // タイトルシーンをセット
  game.pushScene(new TitleScene(game));
  game.start();
}

init();})();
