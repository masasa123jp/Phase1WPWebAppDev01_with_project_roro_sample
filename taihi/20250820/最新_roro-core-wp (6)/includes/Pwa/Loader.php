<?php
/**
 * Progressive Web App (PWA) loader for the RoRo platform.
 *
 * This class registers a minimal service worker and the corresponding
 * registration script on the front end.  The service worker provides
 * basic offline support and can easily be extended or replaced with a
 * more robust implementation such as one generated by Workbox.
 *
 * By bundling the PWA functionality directly into the core plugin we
 * eliminate the need for a separate PWA plugin and ensure that the
 * feature is always available when the core is active.
 *
 * @package RoroCore\Pwa
 */

namespace RoroCore\Pwa;

use function add_action;
use function esc_url;
use function home_url;
use function is_admin;
use function wp_register_script;
use function wp_enqueue_script;
use function wp_add_inline_script;

/**
 * Class Loader
 *
 * Handles registration of a service worker and manifest for the RoRo
 * platform.  The service worker is served from the root of the site
 * at `/roro-sw.js`.  A small client script registers the service
 * worker on the front end.  This implementation intentionally keeps
 * the service worker very simple; projects that require advanced
 * offline caching should integrate Workbox or a similar tool during
 * their build process.
 */
class Loader {
    /**
     * Constructor. Hooks into WordPress actions to bootstrap the PWA.
     */
    public function __construct() {
        add_action( 'wp_enqueue_scripts', [ $this, 'enqueue_scripts' ] );
        add_action( 'init', [ $this, 'serve_service_worker' ] );
    }

    /**
     * Enqueue the service worker registration script on the front end.
     *
     * We register an empty script handle and then attach our inline
     * registration code to it.  This ensures the inline script is
     * printed in the footer, after core WordPress scripts have loaded.
     */
    public function enqueue_scripts() : void {
        if ( is_admin() ) {
            // No need to register the service worker in the admin.
            return;
        }
        $handle = 'roro-core-pwa';
        // Register an empty script so that wp_add_inline_script has a handle.
        wp_register_script( $handle, '', [], RORO_CORE_VERSION, true );
        wp_enqueue_script( $handle );
        $sw_url = esc_url( home_url( '/roro-sw.js' ) );
        $script = "if ('serviceWorker' in navigator) { navigator.serviceWorker.register('" . $sw_url . "').catch(function(e){ console.error('RoRo PWA service worker registration failed', e); }); }";
        wp_add_inline_script( $handle, $script );
    }

    /**
     * Serve the service worker script when requested.
     *
     * If the current request is for `/roro-sw.js` we output a minimal
     * service worker and exit.  This avoids WordPress attempting to
     * further handle the request.  Projects can customise or extend
     * this service worker by modifying this method.
     */
    public function serve_service_worker() : void {
        // Intercept requests for `/roro-sw.js` and serve a dynamic service
        // worker.  Serving the script in PHP means we don't have to
        // distribute a separate static file and can adjust caching
        // strategies on the fly.
        if ( isset( $_SERVER['REQUEST_URI'] ) && preg_match( '#/roro-sw\\.js$#', $_SERVER['REQUEST_URI'] ) ) {
            header( 'Content-Type: application/javascript; charset=utf-8' );
            echo $this->generate_sw();
            exit;
        }
    }

    /**
     * Generate the service worker JavaScript.
     *
     * This implementation leverages Google's Workbox library to
     * implement sensible caching strategies out of the box.  A
     * cache‑first strategy is applied to all assets under
     * `/wp-content/plugins/` (which includes this plugin's assets),
     * whilst a stale‑while‑revalidate strategy is applied to pages and
     * JSON files.  API requests to `/wp-json/` use a network‑first
     * strategy.  Should Workbox fail to load, the script falls back
     * to a basic network proxy to avoid breaking the site.
     *
     * @return string JavaScript source for the service worker.
     */
    private function generate_sw() : string {
        $lines   = [];
        // Load Workbox from Google's CDN.  If it fails to load the
        // fallback code below will still handle fetches gracefully.
        $lines[] = "importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');";
        $lines[] = "// Use Workbox if available";
        $lines[] = "if (self.workbox) {";
        $lines[] = "  workbox.setConfig({ debug: false });";
        // Precache the home page as a fallback when offline.  No
        // revision is specified so that it is fetched fresh on each
        // service worker update.
        $lines[] = "  workbox.precaching.precacheAndRoute([";
        $lines[] = "    { url: '/', revision: null }";
        $lines[] = "  ]);";
        // Cache-first strategy for all plugin assets
        $lines[] = "  workbox.routing.registerRoute(";
        $lines[] = "    ({url}) => url.pathname.includes('/wp-content/plugins/'),";
        $lines[] = "    new workbox.strategies.CacheFirst({";
        $lines[] = "      cacheName: 'roro-core-assets',";
        $lines[] = "      plugins: [ new workbox.expiration.ExpirationPlugin({ maxEntries: 50 }) ]";
        $lines[] = "    })";
        $lines[] = "  );";
        // Stale-while-revalidate for documents and JSON
        $lines[] = "  workbox.routing.registerRoute(";
        $lines[] = "    ({request}) => request.destination === '' || request.destination === 'document' || request.url.endsWith('.json'),";
        $lines[] = "    new workbox.strategies.StaleWhileRevalidate({";
        $lines[] = "      cacheName: 'roro-core-pages'";
        $lines[] = "    })";
        $lines[] = "  );";
        // Network-first for WordPress REST API endpoints
        $lines[] = "  workbox.routing.registerRoute(";
        $lines[] = "    ({url}) => url.pathname.startsWith('/wp-json/'),";
        $lines[] = "    new workbox.strategies.NetworkFirst({";
        $lines[] = "      cacheName: 'roro-core-api',";
        $lines[] = "      networkTimeoutSeconds: 5";
        $lines[] = "    })";
        $lines[] = "  );";
        $lines[] = "} else {";
        // Fallback to a simple proxy if Workbox fails to load
        $lines[] = "  self.addEventListener('install', event => { self.skipWaiting(); });";
        $lines[] = "  self.addEventListener('activate', event => { event.waitUntil(self.clients.claim()); });";
        $lines[] = "  self.addEventListener('fetch', event => { event.respondWith(fetch(event.request)); });";
        $lines[] = "}";
        return implode("\n", $lines) . "\n";
    }
}